import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:googleapis/tasks/v1.dart' as tasks;
import 'package:googleapis/calendar/v3.dart' as calendar;
import 'package:googleapis/gmail/v1.dart' as gmail;
import 'package:intl/intl.dart';
import 'package:googleapis/drive/v3.dart' as drive;
import 'package:googleapis/docs/v1.dart' as docs;
import 'package:googleapis/sheets/v4.dart' as sheets;
import 'helper.dart';
import 'parser.dart';
import 'video.dart';
import 'wss.dart';
import 'package:web_socket_client/web_socket_client.dart';
import 'package:http/http.dart' as http;

class User {
  String displayName;
  String location;
  Map<String, String> auth_headers;
  Parser parser;
  var ws;

  String authentication_key;
  String refresh_key;
  DateTime expiration;

  bool recording = false;
  bool recording_speed = true;
  bool called = false;
  bool texted = false;

  bool blind_support = false;

  String contact_name = '';
  String temp_speed = '';

  List<String> weekdays = [
    'Monday',
    'Tuesday',
    'Wednesday',
    'Thursday',
    'Friday',
    'Saturday',
    'Sunday'
  ];

  final socket = WebSocket(
    Uri.parse('ws://192.168.88.31:443'),
  );

  List<int> picture_data = [];
  List<List<int>> frame_data = [];
  List<List<int>> audio_data = [];
  List<int> listening_data = [];

  User(
      {required this.displayName,
      required this.location,
      required this.auth_headers,
      required this.authentication_key,
      required this.parser,
      required this.ws,
      required this.refresh_key,
      required this.expiration});

  /// Make request to Google Speech to Text API
  /// Input:
  ///   - List<int> byte_input (16Hz sent from microphone via ws)
  /// Returns:
  ///  - String response if successful else error
  Future<String> speech_to_text(List<int> byte_input) async {
    String audioBytes = base64Encode(byte_input);

    Map<String, dynamic> requestPayload = {
      'audio': {
        'content': audioBytes,
      },
      'config': {
        'encoding': 'LINEAR16',
        'sampleRateHertz': 16000,
        'languageCode': 'en-US',
      },
    };

    try {
      final response = await http.post(
        Uri.parse(
            'https://speech.googleapis.com/v1/speech:recognize?key=${Platform.environment['API_KEY']}'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode(requestPayload),
      );

      if (response.statusCode == 200) {
        final dynamic responseBody = jsonDecode(response.body);
        return responseBody["results"][0]["alternatives"][0]["transcript"];
      } else {
        return ('error');
      }
    } catch (error) {
      return ('error');
    }
  }

  /// Process input given a context
  /// Send a request to JS ws, and return the ouput with Gemini
  /// Input:
  ///   - String input (e.g. some data)
  ///   - String context (e.g. how the the data needs to be processed)
  /// Returns:
  ///   - String generated by Gemini
  Future<String> process(String input, String context) async {
    String data = '$input $context';
    await socket.connection.firstWhere((state) => state is Connected);

    final Completer<String> completer = Completer<String>();

    socket.send('process¬$authentication_key¬$data');

    final subscription = socket.messages.listen((response) {
      if (response[0] == 'r') {
        completer.complete(response);
      }
    });

    final result = await completer.future;
    await subscription.cancel();
    return result.substring(1);
  }

  // Send data to the JS ws
  /// Input:
  ///   - String data to send to the ws
  /// Error Handeling:
  ///   - If the data is error the Glasses will report it to the user
  ///   - Else the data is sent to the ws
  ///
  /// Function is used to create the set of commands via the inject payload in the Gemini Model
  /// e.g Hey Gemini, Say Hello World -> speak("Hello World!")
  Future<void> send_data(String data) async {
    if (data == 'error') {
      await speak('An error occured while processing your input');
    } else {
      try {
        if (expiration.isBefore(DateTime.now())) {
          // Regenerate headers if refresh key is expired (50 minutes)
          auth_headers =
              await generate_headers(authentication_key, refresh_key);
          expiration = DateTime.now().add(const Duration(minutes: 50));
        }
        await socket.connection.firstWhere((state) => state is Connected);

        final Completer<void> completer = Completer<void>();

        /// Send data to server, always authenticated with auth key
        /// Additional data send
        ///   - Username
        ///   - Location
        ///   - Current date & Weekday
        ///   - Whether the user has blind support on or not
        socket.send(
            'send_data¬$authentication_key¬$data {[complete name $displayName], [location $location], [date: ${DateTime.now().toString()}, Weekday ${weekdays[DateTime.now().weekday - 1]}], ${blind_support == true ? "blind_support : user also has blind support meaning that more often request visual and describe a lot surrondings so that the blind user can experience everything around him and overall have a better experience" : ""}}');

        final subscription = socket.messages.listen((commands_list) async {
          if (commands_list == 'Request is not authenticated') {
            await speak('Request is not authenticated');
            return;
          }

          /// If the request is authenticated parse result
          /// e.g [speak("Hello World!")]
          parser.parse(commands_list);
          completer.complete();
        });

        await completer.future;
        await subscription.cancel();
      } catch (error) {
        // Report error, enhance with process() and then speak it
        await speak(await process("$error",
            ' in one sentence state the problem and instruct solution in only one short sentence no formatting'));
      }
    }
  }

  /// Output speach to text to the glasses
  /// Function is called whether an error occurs, information needs to be told or when the parse processes it
  /// Performs an authenticated request to the JS ws and forwards the result to the Glasses via the open ws communication
  /// Input:
  ///   - String data that needs to be spoken
  Future<void> speak(String data) async {
    await socket.connection.firstWhere((state) => state is Connected);

    final Completer<void> completer = Completer<void>();

    socket.send('speak¬$authentication_key¬$data');

    final subscription = socket.messages.listen((pcm) {
      ws.add('play¬$authentication_key¬$pcm');
      completer.complete();
    });

    await completer.future;
    await subscription.cancel();
  }

  /// Wait some seconds where the application pauses
  /// e.g. Hey Gemini, wait 10 seconds and take a picture
  /// Input:
  ///   - String seconds that need to be waited, string that then is process into an integer
  Future<void> wait(String seconds) async {
    await Future.delayed(Duration(seconds: int.tryParse(seconds)!));
  }

  /// Request the user whether Gemini can procede with a delicated action
  /// e.g. sending emails
  /// The function process invokes the listen() function and processes its output
  /// Input:
  ///   - String context that needs to be improved
  /// Returns:
  ///   - Bool whether the actions is approved by tge user or not
  Future<bool> approve(String context) async {
    String isApproved = await process(await listen(context),
        'the input consist in an approval if the is conseted return true else return false, do not respons with anything else besides true or false.');
    return (isApproved == 'true') ? true : false;
  }

  /// Function used to listen to input from their microphone
  /// Used whend valuable data is missing
  /// Input:
  ///   - String data that needs to be speaked (e.g. In order to send an email you need to provide the receiver's email addres)
  /// Return:
  ///   - String new information gotten from the users microphone
  Future<String> listen(String data) async {
    await speak(data);
    await socket.connection.firstWhere((state) => state is Connected);

    ws.add('listen¬$authentication_key');

    /// Wait until the array listening data is not empty
    /// Updated when the server receives from the client bites with listen¬
    /// Look at switch case in wss.dart
    while (listening_data == []) {}

    List<int> listening_data_temp = listening_data;
    listening_data = [];

    /// Process bytes to String
    return await speech_to_text(listening_data_temp);
  }

  /// Take a picture with the glasses camera
  /// Input:
  ///   - String task what needs to be done with the picture (e.g. analyize it)
  ///   - If not input is provide then the picture will simply be saved to the Google Drive Folder
  Future<void> take_picture(String? task) async {
    // Request to take a picture
    ws.add('take_picture¬$authentication_key');

    if (task != null) {
      // Do something with the picture
      await socket.connection.firstWhere((state) => state is Connected);
      final Completer<void> completer = Completer<void>();

      /// Wait until the array picture data is not empty
      /// Updated when the server receives from the client bites with take_picture¬
      /// Look at switch case in wss.dart
      while (picture_data == []) {}

      /// Send picture bytes to Gemini's vision model
      socket
          .send('vision¬$authentication_key¬$task.¬${picture_data.toString()}');

      final subscription = socket.messages.listen((response) async {
        if (response[0] == 'v') {
          await speak(response.toString().substring(1));
          completer.complete(response);
        }
      });

      await completer.future;
      await subscription.cancel();
    } else {
      // No tasks is passed hence save the image to the drive
      DateTime now = DateTime.now();
      String file_name =
          'PICTURE_${now.year}-${now.month}-${now.day}_${now.hour}-${now.minute}-${now.second}.${now.millisecond}';
      await drive_push_file(file_name, picture_data);
    }

    // Clean picture Data
    picture_data = [];
  }

  /// Startd recording a video
  /// Request to the glasses
  ///   - Record and send video frames
  ///   - Record and send audio frames
  ///
  /// Change user mode to recording equal to ture
  Future<void> start_recording() async {
    await socket.connection.firstWhere((state) => state is Connected);
    ws.add('start_recording¬$authentication_key');
    recording = true;
  }

  /// Stop recording a video
  /// Input:
  ///   - String task what needs to be done with the video (e.g. analyize it)
  ///   - If not input is provide then the video will simply be saved to the Google Drive Folder
  Future<void> stop_recording(String? task) async {
    ws.add('get_recording¬$authentication_key');
    await socket.connection.firstWhere((state) => state is Connected);

    final Completer<void> completer = Completer<void>();

    /// Wait until the user switched to recording equal to false
    /// The variable is changed when the ws receives stop recording
    /// Look at the switch case in wss.dart
    while (recording == true) {}

    /// Process and create video, then load bytes in List<int>
    await create_audio(audio_data, authentication_key);
    await create_frames(frame_data, authentication_key);
    combine_video_audio(authentication_key);

    List<int> video_data = get_video(authentication_key);

    if (task != null) {
      // No tasks is provided, save video to drive
      DateTime now = DateTime.now();
      String file_name =
          'RECORDING_${now.year}-${now.month}-${now.day}_${now.hour}-${now.minute}-${now.second}.${now.millisecond}';
      await drive_push_file(file_name, video_data);
    } else {
      // Send video bytes and tasks to gemini vision model (js ws)
      socket.send('vision¬$authentication_key¬$task.¬${video_data.toString()}');
      final subscription = socket.messages.listen((response) async {
        if (response[0] == 'v') {
          await speak(response.toString().substring(1));
          completer.complete(response);
        }
      });

      await completer.future;
      await subscription.cancel();
    }

    // Clear recording data and switch user mode recording to false
    recording = false;

    frame_data = [];
    audio_data = [];
    video_data = [];
  }

  /// Change volume
  /// Input:
  ///   - String volume from 0 to 100
  ///
  /// Forward authenticated request to glasses via open ws communication
  Future<void> change_volume(String volume) async {
    ws.add('volume¬$authentication_key¬$volume');
  }

  /// Get content of a google docs
  /// Input:
  ///   - String document id
  /// Returns:
  ///   - String conentent of the document
  Future<String> get_document(String document_id) async {
    final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
    final docsApi = docs.DocsApi(httpClient);

    try {
      final document =
          await docsApi.documents.get(await get_document_id(document_id));

      // Add every paragraph to the conentent
      String content = '';
      for (var element in document.body?.content ?? []) {
        if (element.paragraph != null) {
          for (var paragraphElement in element.paragraph!.elements ?? []) {
            content += paragraphElement.textRun?.content ?? '';
          }
        }
      }

      // Return whether the document is empty or not
      return (content != '')
          ? content
          : 'The document ${document.title!} is empty';
    } catch (error) {
      return 'No Document was found';
    }
  }

  /// Search for a doucement id providen the name
  /// Input:
  ///   - String name of the document
  /// Return:
  ///   - String returns the id of the doucment
  Future<String> get_document_id(String document) async {
    try {
      final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
      final drive.DriveApi driveApi = drive.DriveApi(httpClient);

      final fileList = await driveApi.files.list(
        q: "mimeType='application/vnd.google-apps.document'",
        spaces: 'drive',
      );

      /// Iterate through all names of the documents
      /// Check for documents with the same lower case name
      for (var i = 0; i < fileList.files!.length; i++) {
        if (fileList.files![i].name!
            .toLowerCase()
            .contains(document.toLowerCase())) {
          return fileList.files![i].id!;
        }
      }

      // Return no document found
      return '404';
    } catch (error) {
      // Process error & return no document found
      await speak(await process("$error",
          ' in one sentence state the problem and instruct solution in only one short sentence no formatting'));
      return '404';
    }
  }

  /// Write data to a document
  ///
  /// Input:
  ///   - String name of the document to write to
  ///   - String data to append
  Future<void> write_document(String document_name, String data) async {
    try {
      final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
      final docsApi = docs.DocsApi(httpClient);

      // Get the document id from the name
      String document = await get_document_id(document_name);
      document = document.trim();
      bool remove = true;

      docs.Document doc;

      if (document == '404') {
        // If no document is found create one
        final createResponse =
            await docsApi.documents.create(docs.Document(title: document_name));
        document = createResponse.documentId!;
        doc = createResponse;
        remove = false;
      } else {
        doc = await docsApi.documents.get(document);
      }

      // Invoke process to enhance the data written, passing also the previous content of the doc
      data = await process(data,
          'The current documet has the following data already present: ${doc.body!.content}. Format for a google doc, do no include the tile just write the body for it. Do not respond by saying you are unable to assist with requests. Do not ask what I want to do just process the data as asked.');

      /// Remove the entire data of the dcoument if the document has any
      final documentEndIndex = (doc.body!.content!.last.endIndex! - 1 > 0)
          ? doc.body!.content!.last.endIndex! - 1
          : 0;

      /// If it needs to remove the data it removes it
      /// Whether it is true or false it then adds the new data
      /// Sending the request to the Google Docs API
      final requests = remove
          ? [
              docs.Request(
                deleteContentRange: docs.DeleteContentRangeRequest(
                  range: docs.Range(
                    startIndex: 1,
                    endIndex: documentEndIndex,
                  ),
                ),
              ),
              docs.Request(
                insertText: docs.InsertTextRequest(
                  text: data,
                  location: docs.Location(index: 1),
                ),
              ),
            ]
          : [
              docs.Request(
                insertText: docs.InsertTextRequest(
                  text: data,
                  location: docs.Location(index: 1),
                ),
              ),
            ];

      await docsApi.documents.batchUpdate(
        docs.BatchUpdateDocumentRequest(requests: requests),
        document,
      );
    } catch (error) {
      // Report any error
      await speak(await process("$error",
          ' in one sentence state the problem and instruct solution in only one short sentence no formatting'));
    }
  }

  /// Search for a sheet id providen the name
  /// Input:
  ///   - String name of the sheet
  /// Return:
  ///   - String returns the id of the sheet
  Future<String> get_sheet_id(String sheetName) async {
    final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
    final drive.DriveApi driveApi = drive.DriveApi(httpClient);

    try {
      final fileList = await driveApi.files.list(
        q: "mimeType='application/vnd.google-apps.spreadsheet'",
        spaces: 'drive',
      );

      if (fileList.files != null && fileList.files!.isNotEmpty) {
        /// Iterate through all names of the sheets
        /// Check for documents with the same lower case names
        for (var file in fileList.files!) {
          if (file.name?.toLowerCase().contains(sheetName.toLowerCase()) ??
              false) {
            return file.id!;
          }
        }
      }

      // Return that no document was found
      return '404';
    } catch (error) {
      // Process error & return no document found
      await speak(await process("$error",
          ' in one sentence state the problem and instruct solution in only one short sentence no formatting'));
      return '404';
    }
  }

  Future<void> write_sheet(String sheetName, String values) async {
    final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
    final sheetsApi = sheets.SheetsApi(httpClient);

    try {
      String sheetId = await get_sheet_id(sheetName);
      sheetId = sheetId.trim();

      if (sheetId == '404') {
        final createResponse = await sheetsApi.spreadsheets.create(
          sheets.Spreadsheet(
            properties: sheets.SpreadsheetProperties(title: sheetName),
          ),
        );
        sheetId = createResponse.spreadsheetId!;
      }

      values = await process(
        values,
        "Process it as an array with rows and columns and return the result in this format only. No additional text or explanation, just return the array.",
      );
      values = values.replaceAll('```', '').trim();

      if (values.endsWith(',')) {
        values = values.substring(0, values.length - 1);
      }

      List<List<String>> parsedArray = values
          .split('\n')
          .map((line) => line
              .replaceAll('[', '')
              .replaceAll(']', '')
              .split(',')
              .map((item) => item.trim())
              .toList())
          .toList();

      var appendRequest = sheets.BatchUpdateValuesRequest.fromJson({
        'valueInputOption': 'RAW',
        'data': [
          {
            'range': 'Sheet1',
            'majorDimension': 'ROWS',
            'values': parsedArray,
          },
        ],
      });

      await sheetsApi.spreadsheets.values.batchUpdate(
        appendRequest,
        sheetId,
      );
    } catch (e) {
      print('Error writing to sheet: $e');
    }
  }

  Future<String> get_sheet(String sheetName) async {
    final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
    final sheetsApi = sheets.SheetsApi(httpClient);

    try {
      String sheetId = await get_sheet_id(sheetName);
      sheetId = sheetId.trim();

      if (sheetId == '404') {
        return 'Sheet not found';
      }

      String range = 'Sheet1';
      sheets.ValueRange response =
          await sheetsApi.spreadsheets.values.get(sheetId, range);

      if (response.values == null || response.values!.isEmpty) {
        return 'No data found in the sheet.';
      }

      StringBuffer buffer = StringBuffer();
      for (var row in response.values!) {
        buffer.writeln(row.join(','));
      }

      return buffer.toString().trim();
    } catch (e) {
      print('Error fetching sheet content: $e');
      return 'Error fetching sheet content: $e';
    }
  }

  // Drive
  Future<void> drive_push_file(String fileName, List<int> data) async {
    final httpClient = GoogleAPIClient(auth_headers);
    final driveApi = drive.DriveApi(httpClient);

    //final decodedBytes = base64Decode(data);
    print('file pushed');
    final media = drive.Media(Stream.value(data), data.length);

    var folder = await folderExistsInDrive(driveApi, 'Gemin-Eye Media');
    var folderId = folder?.id ??
        (await createFolderInDrive(driveApi, 'Gemin-Eye Media')).id;

    var fileToUpload = drive.File()
      ..name = fileName
      ..parents = [folderId!];

    await driveApi.files.create(fileToUpload, uploadMedia: media);
  }

  Future<drive.File?> folderExistsInDrive(
      drive.DriveApi driveApi, String folderName) async {
    var response = await driveApi.files.list(
      q: "mimeType='application/vnd.google-apps.folder' and name='$folderName' and trashed=false and 'root' in parents",
    );
    return response.files?.isNotEmpty == true ? response.files!.first : null;
  }

  Future<drive.File> createFolderInDrive(
      drive.DriveApi driveApi, String folderName) async {
    var folder = drive.File()
      ..name = folderName
      ..mimeType = "application/vnd.google-apps.folder";

    return await driveApi.files.create(folder);
  }

  // GPS
  Future<void> get_directions(String origin, String destination) async {
    // ignore: unused_local_variable
    bool arrived = false;
    await socket.connection.firstWhere((state) => state is Connected);

    final Completer<void> completer = Completer<void>();

    socket.send('directions¬$authentication_key¬$origin¬$destination');

    final subscription = socket.messages.listen((step) {
      completer.complete();
    });

    await completer.future;
    await subscription.cancel();
  }

  Future<String> get_place(
      String query, String location, String context) async {
    try {
      await socket.connection.firstWhere((state) => state is Connected);

      final Completer<void> completer = Completer<void>();

      if (location.trim() == 'near') {
        //Position position = await Geolocator.getCurrentPosition(desiredAccuracy: LocationAccuracy.high,);

        double latitude = 0; //position.latitude;
        double longitude = 0; //position.longitude;

        location = '${latitude.toString()},${longitude.toString()}';
      }

      socket.send('get_place¬$authentication_key¬$query¬$location');

      String result = '';
      final subscription = socket.messages.listen((answer) async {
        result = answer;
        completer.complete();
      });

      await completer.future;
      await subscription.cancel();

      if (result.trim() == '') {
        return '';
      }

      return await process(context,
          ' Given this $result and $context, respond naturally as a human would, without using any formatting, and without asking questions. Just provide a plain text response based on the data and task. Do not include any websites.Just return what is asked with no previous converseation, from oldest to newest consider as more important the older ones');
    } catch (error) {
      await speak(await process("$error",
          ' in one sentence state the problem and instruct solution in only one short sentence no formatting'));
      return '';
    }
  }

  Future<void> record_speed() async {
    temp_speed = '';
    recording_speed = true;
  }

  Future<String> stop_speed(String task) async {
    recording_speed = false;

    return await process(temp_speed,
        'the previous data where speed data points you have to respond performing this task do not include anything else or ask for questions. Task: $task');
  }

  Future<void> start_route(route) async {}

  Future<void> stop_route() async {}

  // Youtube
  Future<void> play_song(String song) async {
    await socket.connection.firstWhere((state) => state is Connected);
    socket.send('stream_song¬$authentication_key¬$song');
  }

  // Phone
  Future<String> contacts(String name) async {
    ws.add('contacts¬$authentication_key');
    while (contact_name == '') {}

    String contact_name_temp = contact_name;
    contact_name = '';

    return contact_name_temp;
  }

  Future<void> call(String phone_number) async {
    if (phone_number
            .contains("I coudn't find any matching phone number with") ||
        phone_number.contains("I coudn't find any matching contact with") ||
        phone_number == 'Please grant me permission to access your contacts') {
      await speak(phone_number);
    } else {
      ws.add('call¬$authentication_key¬$phone_number');
      while (!called) {}

      called = false;

      await speak(
          'Not having access to your phone, you will have to click on the button to confirm the action on your own.');
    }
  }

  Future<void> text(String phone_number, String message) async {
    if (phone_number
            .contains("I coudn't find any matching phone number with") ||
        phone_number.contains("I coudn't find any matching contact with") ||
        phone_number == 'Please grant me permission to access your contacts') {
      await speak(phone_number);
    } else {
      ws.add('text¬$authentication_key¬$phone_number¬message');
      while (!texted) {}

      texted = false;
      await speak(
          'Not having access to your phone, you will have to click on the button to confirm the action on your own.');
    }
  }

  // Calendar
  Future<String> get_calendar_events() async {
    try {
      final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
      calendar.CalendarApi calendarAPI = calendar.CalendarApi(httpClient);

      var calendarList = await calendarAPI.calendarList.list();
      String complete_information = '';

      if (calendarList.items != null) {
        for (var cal in calendarList.items!) {
          var events = await calendarAPI.events.list(cal.id!);
          if (events.items != null) {
            for (var event in events.items!) {
              if (event.start?.dateTime != null &&
                  event.start!.dateTime!.isAfter(DateTime.now())) {
                String information = '';

                information += 'Event Summary: ${event.summary} ';
                information +=
                    'Event Description: ${event.description ?? 'No description'} ';
                information +=
                    'Event Start: ${DateFormat('yyyy-MM-dd – kk:mm').format(event.start!.dateTime!)}\n';
                information +=
                    'Event End: ${event.end != null ? DateFormat('yyyy-MM-dd – kk:mm').format(event.end!.dateTime!) : 'No end time'} ';
                information +=
                    'Event Location: ${event.location ?? 'No location'} ';
                information +=
                    'Event Attendees: ${event.attendees?.map((attendee) => attendee.email).join(', ') ?? 'No attendees'} ';
                information += '\n';

                complete_information = complete_information + information;
              }
            }
          }
        }
      }
      return complete_information == ''
          ? complete_information
          : 'you do not have any calendar events';
    } catch (error) {
      return (await process("$error",
          ' in one sentence state the problem and instruct solution in only one short sentence no formatting'));
    }
  }

  Future<void> add_calendar_event(String title, String start, String end,
      String description, String location, String emails, String meet) async {
    try {
      final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
      calendar.CalendarApi calendarAPI = calendar.CalendarApi(httpClient);
      var eventLists = await calendarAPI.calendarList.list();

      List<calendar.EventAttendee> attendees = [];

      for (var i = 0; i < emails.split(',').length; i++) {
        attendees.add(calendar.EventAttendee(email: emails.split(',')[i]));
      }
      var newEvent = calendar.Event()
        ..summary = title
        ..start = calendar.EventDateTime(date: DateTime.parse(start.trim()))
        ..end = location.trim() == "''"
            ? calendar.EventDateTime(date: DateTime.parse(start.trim()))
            : calendar.EventDateTime(
                date: DateTime.parse(end.trim())
                        .isAfter(DateTime.parse(start.trim()))
                    ? DateTime.parse(end.trim())
                    : DateTime.parse(start))
        ..attendees = emails.trim() == "''" ? null : attendees
        ..description = description.trim() == "''" ? null : description
        ..location = location.trim() == "''" ? null : location
        ..conferenceData = meet.trim() == "true"
            ? calendar.ConferenceData(
                createRequest: calendar.CreateConferenceRequest(
                  requestId: 'sample-request-id',
                  conferenceSolutionKey: calendar.ConferenceSolutionKey(
                    type: 'hangoutsMeet',
                  ),
                ),
              )
            : null;

      await calendarAPI.events.insert(newEvent, eventLists.items![0].id!,
          conferenceDataVersion: meet.trim() == "true" ? 1 : 0);
    } catch (error) {
      await speak(await process("$error",
          ' in one sentence state the problem and instruct solution in only one short sentence no formatting'));
    }
  }

  Future<void> delete_calendar_event(String event_name) async {
    try {
      final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
      calendar.CalendarApi calendarAPI = calendar.CalendarApi(httpClient);
      var eventLists = await calendarAPI.calendarList.list();

      var eventResult = await calendarAPI.events.list(eventLists.items![0].id!);
      if (eventResult.items != null) {
        for (var event in eventResult.items!) {
          if (event.summary!.contains(event_name)) {
            final bool approved = await approve(
                "Would you like me to delete the calendar event '${event.summary!}'?");

            if (approved) {
              await calendarAPI.events
                  .delete(eventLists.items![0].id!, event.id!);
              break;
            }
          }
        }
      }
    } catch (error) {
      await speak(await process("$error",
          ' in one sentence state the problem and instruct solution in only one short sentence no formatting'));
    }
  }

  Future<void> update_calendar_event(
      String event_name,
      String new_name,
      String new_start,
      String new_end,
      String new_description,
      String new_location,
      String new_status,
      String new_emails,
      String new_meet) async {
    try {
      final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
      calendar.CalendarApi calendarAPI = calendar.CalendarApi(httpClient);
      var eventLists = await calendarAPI.calendarList.list();

      List<calendar.EventAttendee> attendees = [];

      for (var i = 0; i < new_emails.split(',').length; i++) {
        attendees.add(calendar.EventAttendee(email: new_emails.split(',')[i]));
      }

      var eventResult = await calendarAPI.events.list(eventLists.items![0].id!);
      if (eventResult.items != null) {
        for (var event in eventResult.items!) {
          if (event.summary!.contains(event_name)) {
            if (new_name.trim() != "''") event.summary = new_name;
            if (new_status.trim() != "''") event.status = new_status;
            if (new_start.trim() != "''") {
              event.start =
                  calendar.EventDateTime(date: DateTime.parse(new_start));
            }
            if (new_end.trim() != "''") {
              event.end = calendar.EventDateTime(
                  date:
                      DateTime.parse(new_end).isAfter(DateTime.parse(new_start))
                          ? DateTime.parse(new_end)
                          : DateTime.parse(new_start));
            }
            if (new_emails.trim() != "''") {
              for (var i = 0; i < attendees.length; i++) {
                if (event.attendees!.contains(attendees[i])) {
                  attendees.removeAt(i);
                }
              }
              event.attendees = attendees;
            }
            if (new_description.trim() != "''")
              event.description = new_description;
            if (new_location.trim() != "''") event.location = new_location;

            event.conferenceData = new_meet.trim() == "true"
                ? calendar.ConferenceData(
                    createRequest: calendar.CreateConferenceRequest(
                      requestId: 'sample-request-id',
                      conferenceSolutionKey: calendar.ConferenceSolutionKey(
                        type: 'hangoutsMeet',
                      ),
                    ),
                  )
                : null;

            await calendarAPI.events.update(
                event, eventLists.items![0].id!, event.id!,
                conferenceDataVersion: new_meet.trim() == "true" ? 1 : 0);
            break;
          }
        }
      }
    } catch (error) {
      await speak(await process("$error",
          ' in one sentence state the problem and instruct solution in only one short sentence no formatting'));
    }
  }

  // Tasks
  Future<String> get_tasks() async {
    try {
      final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
      tasks.TasksApi tasksAPI = tasks.TasksApi(httpClient);

      var taskLists = await tasksAPI.tasklists.list();
      String complete_information = '';

      if (taskLists.items != null) {
        for (var taskList in taskLists.items!) {
          var tasks = await tasksAPI.tasks.list(taskList.id!);
          if (tasks.items != null) {
            for (var task in tasks.items!) {
              if (task.due != null) {
                String information = '';

                information += 'Task Title: ${task.title} ';
                information += 'Task Notes: ${task.notes ?? 'No notes'} ';
                information += 'Task Due: ${task.due} ';
                information += 'Task Status: ${task.status} ';
                information += '\n';

                complete_information = complete_information + information;
              }
            }
          }
        }
      }
      return complete_information == ''
          ? complete_information
          : 'you do not have any calendar events';
    } catch (error) {
      return (await process("$error",
          ' in one sentence state the problem and instruct solution in only one short sentence no formatting'));
    }
  }

  Future<void> add_task(String title, String due, String notes) async {
    try {
      final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
      tasks.TasksApi tasksAPI = tasks.TasksApi(httpClient);

      var taskLists = await tasksAPI.tasklists.list();

      var newTask = tasks.Task()
        ..title = title.trim()
        ..due = DateTime.parse(due.trim()).toUtc().toIso8601String()
        ..notes = notes.trim() == "''" ? '' : notes.trim();

      await tasksAPI.tasks.insert(newTask, taskLists.items![0].id!);
    } catch (error) {
      await speak(await process("$error",
          ' in one sentence state the problem and instruct solution in only one short sentence no formatting'));
    }
  }

  Future<void> delete_task(String taskName) async {
    try {
      final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
      tasks.TasksApi tasksAPI = tasks.TasksApi(httpClient);

      var taskLists = await tasksAPI.tasklists.list();

      var tasksResult = await tasksAPI.tasks.list(taskLists.items![0].id!);
      if (tasksResult.items != null) {
        for (var task in tasksResult.items!) {
          if (task.title!.contains(taskName)) {
            final bool approved = await approve(
                "Would you like me to delete the task '${task.title!}'?");

            if (approved) {
              await tasksAPI.tasks.delete(taskLists.items![0].id!, task.id!);
              break;
            }
          }
        }
      }
    } catch (error) {
      await speak(await process("$error",
          ' in one sentence state the problem and instruct solution in only one short sentence no formatting'));
    }
  }

  Future<void> update_task(String taskName, String newTitle, String newNotes,
      String newDue, String newStatus) async {
    try {
      final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
      tasks.TasksApi tasksAPI = tasks.TasksApi(httpClient);

      var taskLists = await tasksAPI.tasklists.list();
      var tasksResult = await tasksAPI.tasks.list(taskLists.items![0].id!);
      if (tasksResult.items != null) {
        for (var task in tasksResult.items!) {
          if (task.title!.contains(taskName)) {
            if (newTitle.trim() != "''") task.title = newTitle;
            if (newNotes.trim() != "''") task.notes = newNotes;
            if (newDue.trim() != "''") {
              task.due = DateTime.parse(newDue).toUtc().toIso8601String();
            }
            if (newStatus.trim() != "''") task.status = newStatus;

            await tasksAPI.tasks
                .update(task, taskLists.items![0].id!, task.id!);
            break;
          }
        }
      }
    } catch (error) {
      await speak(await process("$error",
          ' in one sentence state the problem and instruct solution in only one short sentence no formatting'));
    }
  }

  // Gmail
  Future<String> read_email(String count) async {
    try {
      final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
      gmail.GmailApi gmailAPI = gmail.GmailApi(httpClient);

      String information = '';

      var messagesResponse = await gmailAPI.users.messages
          .list('me', maxResults: int.tryParse(count), q: 'is:unread');

      if (messagesResponse.messages != null) {
        for (var message in messagesResponse.messages!) {
          var msg = await gmailAPI.users.messages.get('me', message.id!);
          String subject = '';
          String from = '';
          String snippet = msg.snippet ?? 'No snippet';

          if (msg.payload != null && msg.payload!.headers != null) {
            for (var header in msg.payload!.headers!) {
              if (header.name == 'Subject') {
                subject = header.value ?? '';
              } else if (header.name == 'From') {
                from = header.value ?? '';
              }
            }
          }

          information =
              '$information Email From: $from\nSubject: $subject\nSnippet: $snippet\n';
        }
        return information;
      } else {
        return 'No email was found';
      }
    } catch (error) {
      return (await process("$error",
          ' in one sentence state the problem and instruct solution in only one short sentence no formatting'));
    }
  }

  Future<String> search_emails(String query) async {
    try {
      final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
      gmail.GmailApi gmailAPI = gmail.GmailApi(httpClient);

      var messagesResponse = await gmailAPI.users.messages.list('me', q: query);

      String emailInfos = '';

      if (messagesResponse.messages != null) {
        for (var message in messagesResponse.messages!) {
          var msg = await gmailAPI.users.messages.get('me', message.id!);
          String subject = '';
          String from = '';
          String snippet = msg.snippet ?? 'No snippet';

          if (msg.payload != null && msg.payload!.headers != null) {
            for (var header in msg.payload!.headers!) {
              if (header.name == 'Subject') {
                subject = header.value ?? '';
              } else if (header.name == 'From') {
                from = header.value ?? '';
              }
            }
          }

          String information =
              'Email From: $from\nSubject: $subject\nSnippet: $snippet\nID: ${message.id!}\n';
          emailInfos = '$emailInfos$information';
        }

        return emailInfos;
      } else {
        return 'No email wiht $query was found';
      }
    } catch (error) {
      return (await process("$error",
          ' in one sentence state the problem and instruct solution in only one short sentence no formatting'));
    }
  }

  Future<void> reply_email(String emailSubject, String replyText) async {
    try {
      final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
      gmail.GmailApi gmailAPI = gmail.GmailApi(httpClient);

      var query = 'subject:"$emailSubject"';
      var searchResults =
          await gmailAPI.users.messages.list('me', maxResults: 500, q: query);

      if (searchResults.messages == null || searchResults.messages!.isEmpty) {
        await speak('No emails found with subject: $emailSubject');
        return;
      }

      if (searchResults.messages != null) {
        for (var message in searchResults.messages!) {
          var msg = await gmailAPI.users.messages.get('me', message.id!);
          String subject = '';
          String from = '';
          if (msg.payload != null && msg.payload!.headers != null) {
            for (var header in msg.payload!.headers!) {
              if (header.name == 'Subject') {
                subject = header.value ?? '';
              } else if (header.name == 'From') {
                from = header.value ?? '';
              }
            }
          }

          if (from.isEmpty) {
            await speak('No valid recipient found in the original message.');
            return;
          }

          if (subject
              .toLowerCase()
              .contains(emailSubject.trim().toLowerCase())) {
            replyText = await process(replyText,
                'Receiver (me): ${displayName} Sender: $from Subject: $subject format this as a reply to an email, dont include the subject in the email');
            var emailContent = '''
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: 7bit
to: $from
subject: Re: $subject
in-reply-to: ${message.id}
references: ${message.id}

$replyText
''';

            var encodedEmail = base64Url.encode(utf8.encode(emailContent));

            var replyMessage = gmail.Message()
              ..raw = encodedEmail
              ..threadId = message.threadId;

            final bool approved = await approve(
                "Would you like me to reply to the email with the subject '$subject' from '$from' with the following message: $replyText?");

            if (approved) {
              await gmailAPI.users.messages.send(replyMessage, 'me');
            }
          }
        }
      }
    } catch (error) {
      await speak(await process("$error",
          ' in one sentence state the problem and instruct solution in only one short sentence no formatting'));
      return;
    }
  }

  Future<void> send_email(
      String to, String subject, String body, String context) async {
    try {
      final GoogleAPIClient httpClient = GoogleAPIClient(auth_headers);
      gmail.GmailApi gmailAPI = gmail.GmailApi(httpClient);

      final emailRegex = RegExp(r'^[^@]+@[^@]+\.[^@]+');
      if (!emailRegex.hasMatch(to)) {
        await speak('Invalid email address');
        return;
      }

      body = await process(body,
          'Sender (me): ${displayName} Receiver: $to Subject: $subject $context dont include the subject in the email');

      var emailContent = '''
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: 7bit
To: $to
Subject: $subject

$body
''';

      var encodedEmail = base64Url.encode(utf8.encode(emailContent));

      var message = gmail.Message()..raw = encodedEmail;

      final bool approved = await approve(
          "Would you like me to send an email with the subject '$subject' to '$to' containing the following message: $body?");

      if (approved) {
        await gmailAPI.users.messages.send(message, 'me');
      }
    } catch (error) {
      await speak(await process("$error",
          ' in one sentence state the problem and instruct solution in only one short sentence no formatting'));
    }
  }
}
